<!-- https://scotch.io/tutorials/understanding-hoisting-in-javascript -->

<!DOCTYPE html>
<head lang="en">
<title>Task</title>
</head>
<body>
    <script>
//**************************************************************************************/
//         let num = myFunction(5)
//         console.log(num)  // Result: 125
// //the below function was hoisted with all its details as we used a function declaration
// //but story is different if we declare function using expression  =
//         function myFunction(y) {
//         return y * y *y;
//         }

//**************************************************************************************/
//The following example will fail spectacularly. 
//The variable declaration for myFunction is hoisted before the function call. 
//However, since the assignment to myFunction is not hoisted, an exception is thrown for trying to call a non-function variable.
        

        // let num = myFunction(5);
        // console.log(num);

        // let myFunction = function(y){   //var myFunction is hoisted but assignment to myFunction is not hoisted
        //     return(y*y);
        // }

//**************************************************************************************/
// you should see the same happening for arrow function as it uses assignment too
        // let num = myFunction(5);
        // console.log(num);

        // let myFunction = (y) =>{   //var myFunction is hoisted but assignment to myFunction is not hoisted
        //     return(y*y);
        // }

//**************************************************************************************/
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++IMPORTANT NOTE+++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// If you define a function like this:

        let num1 = myFunction(5)
        console.log(num1)  // Result: 125

//the function has been hoisted and it is now a global function
        function myFunction(y) {  
        return y * y *y;
        }

//Now if you define the same named function in the code but later, like this:

        let num2 = myFunction(5);
        console.log(num2);// Result: 125

//"let myFunction" is hoisted but the NEW assignment to myFunction is not hoisted,
//as a result it will use older myFunction that was defined globally and the result will be y*y*y instead of y*y                                         
        let myFunction = function(y){   
            return(y*y);
        }

//Above IMPORTANT NOTE is for console log only.For HTML it will give an error that myFunction has already been declared
    </script>
</body>